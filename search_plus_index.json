{"./":{"url":"./","title":"Evday","keywords":"","body":"Welcome to Evday's blog!         说明 笔记使用Markdown格式编写 , 托管于Github , 使用GitHub Pages 和 Gitbook两种方式展示 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"SUMMARY","keywords":"","body":"Summary Evday SUMMARY Flask 基础知识 MySQL数据库 ​​ wtforms 源码流程​​ 函数知识体系​​ 常用模块和包​​ 爬虫​​ 网络编程 面向对象​​ "},"Python/Flask 框架/Flask 基础知识.html":{"url":"Python/Flask 框架/Flask 基础知识.html","title":"Flask 基础知识","keywords":"","body":"Flask 框架:four_leaf_clover: Flask 是一个基于Python 开发，依赖于jinjia2 模板引擎 和 Werkzeug WSGI 服务的微型web开发框架。 Table of contents 启动Flask :deciduous_tree: pip install flask # 安装 from flask import Flask # 新建flask 项目自动生成，妈个鸡的我居然没写出来 app = Flask(__name__) # 实例化Flask 类 app.route(\"/\") # 路由 def hello_world(): # 视图 return \"Hello World\" if __name__ == \"__main__\": app.run() 配置文件:deciduous_tree: 设置配置文件的4种方式:palm_tree: 方式一，直接写入脚本:leaves: from flask import Flask app = Flask(__name__) app.Config[\"DEBUG\"] = True app.Config[\"SECRTE_key\"] = \"lift if short you need python\" #可以自典的update app.config.update( DEBUG = True, SECRTE_key = \"lift if short you need python\" ) 方式二，写入环境变量:leaves: set YOURAPPLICATION_SETTINGS=\\path\\to\\settings.cfg # 将配置文件路径写入到环境变量 from flask import Flask app = Flask(__name__) app.Config.from_envvar(\"YOURAPPLICATION_SETTINGS\") 方式三，写入配置文件:leaves: # config.py SECRET_KEY = \"life is short you need python\" DEBUG = True # 使用方式一，导入类 import config app = Flask(__name__) app.Config.from_object(config) # 使用方式二 app.Config.from_object(\"config.py\") 方式四，创建不同的类:leaves: # config.py class Config(object): DEBUG = False TESTING = False DATABASE_URI = 'sqlite://:memory:' class ProductionConfig(Config): DATABASE_URI = 'mysql://user@localhost/foo' class DevelopmentConfig(Config): DEBUG = True class TestingConfig(Config): TESTING = True config = { 'development': DevelopmentConfig, 'testing': TestingConfig, 'default': DevelopmentConfig } # 使用 from flask import Flask app = Flask(__name__) app.config.from_obj(Config[\"development\"]) 路由系统:deciduous_tree: 添加路由的两种方式:palm_tree: # 装饰器方法 from flask import Flask @app.route(\"/\") def hello_world(): return \"hello world\" # 方式二，add_url_rule 装饰器方法在源码中也是用的add_url_rule def hello_world(): return \"hello world\" app.add_url_rule(rule=\"/\",endpoint=\"index\",view_func=hello_world,methods=[\"GET\",\"POST\"]) url 传参:palm_tree: @app.route('/user/') # 匹配字符串 @app.route('/book/') # 数字 @app.route('/price/') # 浮点数 app.route()&app.add_url_rule() 参数 :palm_tree: rule # url view_func # 视图函数 defaults = None # 默认值，url需要参数时，使用defaults = {\"k\",\"v\"} 提供参数 endpoint = None # 用于反向生成url, url_for(\"名称\") methods = None #允许请求的方式 strict_slashes = None # 对url 后的“/” 是否严格要求 redirect_to # 重定向地址 自定义路由匹配规则:palm_tree: from flask import Flask app = Flask(__name__) from werkzeug.routing import BaseConverter class RegexConverter(BaseConverter): \"\"\"自定义url匹配正则表达式\"\"\" def __init__(self, map,regex): super(RegexConverter,self).__init__(map) self.regex = regex def to_python(self, value): \"\"\" 路由匹配时，匹配成功后传递给视图函数中参数的值 :param value: :return: \"\"\" return int(value) def to_url(self, value): \"\"\" 使用url_for反向生成URL时，传递的参数经过该方法处理，返回的值用于生成URL中的参数 :param value: :return: \"\"\" val = super(RegexConverter,self).to_url(value) return val # 添加到converters app.url_map.converters['regex'] = RegexConverter # 进行使用 app.route('/index/',endpoint=\"index\") def index(nid): url_for(\"index\",nid=123) # 反向生成，就会去执行to_url方法 return \"Index\" if __name__ == \"__main__\": app.run() 视图:deciduous_tree: CBV:palm_tree: from flask import Flask,render_template,redirect,request,session,views app = Flask(__name__) app.secrect_key = \"hello world\" def wrapper(func): # 登录验证装饰器 def inner(*args,**kwargs): if not session.get(\"user_info\"): return redirect(\"/login\") ret = func(*args,**kwargs) return ret return inner class IndexView(views.MethosView): methods = [\"GET\",\"POST\"] decorators = [wrapper,] # 给所有方法加上登录验证的装饰器 def get(self): #如果是get请求需要执行的代码 v = url_for('index') print(v) return \"GET\" def post(self): #如果是post请求执行的代码 return \"POST\" app.add_url_rule('/index',view_func = IndexView.as_view(name='index'))m #name 相当于endpoint if __name__ == \"__main__\": app.run() FBV:palm_tree: # 装饰器方法 from flask import Flask @app.route(\"/\") def hello_world(): return \"hello world\" # 方式二，add_url_rule 装饰器方法在源码中也是用的add_url_rule def hello_world(): return \"hello world\" app.add_url_rule(rule=\"/\",endpoint=\"index\",view_func=hello_world,methods=[\"GET\",\"POST\"]) 请求与响应:deciduous_tree: from flask import Flask from flask import request from flask import render_template from flask import redirect from flask import make_response app = Flask(__name__) @app.route('/login.html', methods=['GET', \"POST\"]) def login(): # 请求相关信息 # request.method 请求方法 # request.args url参数 # request.form POST和PUT请求解析的 MultiDict（一键多值字典）。 # request.values CombinedMultiDict，内容是form和args # request.cookies 请求的cookies，类型是dict。 # request.headers 请求头，字典类型。 # request.path 路径 # request.full_path 全路径 # request.script_root # request.url # request.base_url # request.url_root # request.host_url # request.host # request.files # 文件 # obj = request.files['the_file_name'] # obj.save('/var/www/uploads/' + secure_filename(f.filename)) # 响应相关信息 # return \"字符串\" # return render_template('html模板路径',**{}) # return redirect('/index.html') # response = make_response(render_template('index.html')) # response是flask.wrappers.Response类型 # response.delete_cookie('key') # response.set_cookie('key', 'value') # response.headers['X-Something'] = 'A value' # return response return \"内容\" if __name__ == '__main__': app.run() 模板:deciduous_tree: 防止xss 攻击:palm_tree: # 后端代码实现,django 用的是make_safe return Makeup(\"hello world\") # 前端代码实现,用法同django {{ str|safe }} jinjia2 视图支持传递函数，函数可以传参:palm_tree: def test(a,b) return a+b @app.route(\"/index\") def index(): return render_template('index.html',test=test) # index.html {{ test(1,2) }} template_global&template_filter :palm_tree: @app.template_global() def sb(a1, a2): return a1 + a2 @app.template_filter() def db(a1, a2, a3): return a1 + a2 + a3 # 使用 {sb(1,2)}} {{ 1|db(2,3)}} Flask 中的宏:palm_tree: {% macro page(data) -%} # 这是一个分页的宏 {% if data %} 首页 {% if data.has_prev %} 上一页 {% else %} 上一页 {% endif %} {% for v in data.iter_pages() %} {% if v == data.page %} {{ v }} {% else %}{{ v }} {% endif %} {% endfor %} {% if data.has_next %} 下一页 {% else %} 下一页 {% endif %} 尾页 {% endif %} {%- endmacro %} 蓝图:deciduous_tree: # admin 文件夹中的__init__ 文件 from flask import Blueprint admin = Blueprint('admin',__name__) from . import views # app 文件夹中的__init__ 文件 from flask import Flask app = Flask(__name__) from .admin import admin as admin_blueprint app.register_blueprint(admin_blueprint,url_prefix = '/admin') # url_prefix 前缀 session :deciduous_tree: # 除请求对象之外，还有一个 session 对象。它允许你在不同请求间存储特定用户的信息。它是在 Cookies 的基础上实现的，并且对 Cookies 进行密钥签名要使用会话，你需要设置一个密钥。 from flask import session,Flask app.secret_key = \"hello world\" @app.route(\"/\") def login(): session[\"user\"] = \"xiang\" # 设置session del session[\"user\"] # 删除session if __name__ == \"__main__\": app.run() 闪现:deciduous_tree: # flash 本质由session创建，取一次就没有了，相当于pop掉了 flash(\"角色已存在!\",\"err\") # 后台代码 {% for msg in get_flashed_messages(category_filter=[\"ok\"]) %} # 可以传状态，提示错误或者成功 × 操作成功 {{ msg }} {% endfor %} {% for msg in get_flashed_messages(category_filter=[\"err\"]) %} × 操作失败 {{ msg }} {% endfor %} 伪中间件:deciduous_tree: # 在flask 中并没有类似与Django的中间件，而是通过三个特殊的装饰器来做类似中间件的功能 @app.before_first_request # 当程序运行起来，第一个请求来的时候就只执行一次，下次再来就不会在执行了 @app.before_request # 请求之前 @app.after_request # 请求之后 # 可以在这里对用户的权限做验证 "},"Python/MySQL数据库 ​​.html":{"url":"Python/MySQL数据库 ​​.html","title":"MySQL数据库 ​​","keywords":"","body":"MySQL数据库 :four_leaf_clover: Table of contents :one: 库操作:deciduous_tree: show databases (查看所有的数据库) use 数据库名 DROP DATABASES 数据库名 ALERT DATABASE 数据库名 charset utf8 (修改数据库字符编码) :two: 存储引擎:deciduous_tree: 什么是存储引擎 现实生活中我们使用文件存储不同类型的文件，每种文件类型对应各自不同的处理机制，如比如处理文本用txt类型，处理表格用excel，处理图片用png等。同样数据库中的表也有不同的的类型，表的类型不同，会对应不同的mysql处理机制，这些表类型就称为存储引擎。存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。 MySQL 中都有哪些存储引擎，它们有什么区别 在Windows中可以使用命令 show engines 查看所有的存储引擎 在Linux 中使用 show engines\\G 查看所有存储引擎 InnoDB 是MySQL 默认的存储引擎 ，其特点是支持事物、支持行锁、支持外键，并且默认读取的时候不会产生锁。 MyISAM 不支持事物，支持表锁、支持全文索引。在 MySQL 5.5.8 版本之前是默认的存储引擎 NDB 是 一个集群存储引擎，其特点是将数据全部放在内存中，因此按主键查找的速度相当快。(OLTP) Memory 数据存放在内存中，数据库重启或发生崩溃，表中的数据都会消失。Memory 默认使用哈希索引。 ​ (OLTP数据库应用中的临时表)和(OLAP数据库应用中的维度表) Inforbright 特点是存储是按照行而非列的，适合 (OLAP) 的数据库应用。 OLTP 和OLAP的区别 数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 OLTP 联机事物处理系统，表示事务性非常高的系统，一般是高可用的在线系统，在这样的系统中，以小的事务以及小的查询为主，单个数据库中每秒处理的交易成百上千个，Select 语句执行量每秒高达成千上万个。常见的OLTP系统有，电子商务，银行，证券等。 OLAP 联机分析处理系统，也就是数据仓库。所谓数据仓库是对于大量已经由OLTP形成的数据的一种分析型的数据库，用于处理商业智能、决策支持等重要的决策信息；数据仓库是在数据库应用到一定程序之后而对历史数据的加工与分析，读取较多，更新较少，(大数据) :three: 表操作:deciduous_tree: 表的基本操作 create databases db1 charset utf8; # 创建数据库 use db1; # 使用数据库 create table t1(id int,name varchar(30),sex enum(\"male\",\"female\"),age int(3)); # 创建表t1 show tables; # 显示当前库里的所有表 desc t1; # 查看表结构 show create table t1\\G; #查看详细表结构，存储引擎可以从这里查看 select id,name,sex,age from t1; # 从t1表中查找id,name,sex,age字段对应的数据 insert into t1 values (1,\"bai\",\"male\",18),(2,\"xiang\",\"female\",19); # 往t1表中插入数据 数据库中的数据类型 数值类型 1）整数类型 存储年龄、等级、id、各种号码等 分为 smallint int bigint 默认长度为11，不用刻意指定 2）浮点型 存储身高、体重、薪资 float(单精度，非准确)、double(双精度，非准确)、decimal(准确小数值) 日期类型 存储用户注册时间、文章发布时间、员工入职时间、出生时间等 date(日期)、time(时分秒)、datetime(日期+时分秒)、year(年)、timestamp(日期+时分秒) ；datetime(8字节存储空间) 对比 timestamp(4字节存储空间) 浪费空间 字符串类型 char (定长，简单粗暴、浪费空间、存取速度快) varchar(不定长，精准、节省空间、存取速度慢) 枚举、集合类型 enum 单选 只能在给定的值当中选择一个 set 多选 在给定的值当中选一个或者多个 完整性约束 NOT NULL & default # NULL NULL 不可为空，必须赋值，可指定默认值 default,不指定默认显示NULL eg: sex enum(\"male\",\"female\") not null default \"male\" UNIQUE #唯一 eg: #方法一 create table department(id int,name varchar(10) unique,comment varchar(100)) #方法二 create table department(id int,name varchar(10),comment varchar(100) constraint uk_name unique(name)) NOT NULL & UNIQUE # 不为空且唯一 （主键） eg: create table t1(id int not null unique) # 联合唯一 eg: create table service(id int primary key auto_increment,name varchar(10),host varchar(20) not null ,port int not null,unique(host,port)) # 联合唯一 PRIMARY KEY #主键primary key是innodb存储引擎组织数据的依据，innodb 称为索引组织表，一张表只有一个主键 # 单列主键 eg：create table department(id int primary key,name varchar(20),comment varchar(20)) create table department(id int,name varchar(20),constraint pk_name primary key(id)) # 双列主键(不常用) eg: create table service(ip varchar(20),port char(5),service_name varchar(10) not null primary key(ip,port)) AUTO_INCREMENT #自增，且被约束字段同时被key约束 eg: create table student(id int primary key auto_increment,name varchar(20)) insert into student values ('bai'),('xiaotu'); # 不指定ID 自增 insert into student values (3,\"xiang\"),(4,\"laozhongyi\"); # 也可指定id ps: # 对于自增字段 使用delete删除后，再插入值，该字段任然按照前面的位置继续增长 eg: delete from student; # 只删一行数据 指定删除 delete from student where id = 1； # 可以使用truncate清空表，这时候自增字段从1开始 eg: truncate student; FOREIGN KEY # 外键 表类型必须是InnoDB 存储引擎，且被关联字段保证唯一 eg: create table press(id int primary key auto_increment,name varchar(20)); #press_id外键，关联父表（press主键id），同步更新，同步删除 create table book(id int primary key auto_increment,name varchar(20),press_id int not null,foreign key(press_id) references press(id)on delete cascadeon update cascade); # 多对多 eg: create table author(id int primary key auto_increment,name varchar(20)); # 存放多对多关系(第三张表) create table author2book(id int not null unique auto_increment,author_id int not null, book_id int not null,constraint fk_author foreign key(author_id) references author(id) on delete cascade on update cascade,constraint fk_book foreign key(book_id) references book(id) on delete cascade on update cascade,primary key(author_id,book_id)); # 给 author 插入数据 insert into author(name) values('bai'),('xiang'),('laozhongyi'),('huazai'); # 一对一 学生一定是一个客户，客户不一定是学生，但有可能成为学习 eg: create table customer(id int primary key auto_increment,name varchar(20) not null,qq varchar(20) not null,phone char(11) not null); create table student(id int primary key auto_increment,class_name varchar(20) not null, customer_id int unique,foreign key(customer_id) references customer(id) on delete cascade on update cascade); 修改表 ALTER TABLE 1) #修改存储引擎 eg: alter table book engine=innodb; 2) #添加字段 eg: alter table student add name varchar(20) not null,add age int not null default=22; 3) #删除字段 eg: alter table student drop qq; 4) #修改字段类型modify eg: alter table student modify id int(11) not null primary key auto_increment; #修改为主键 5）#增加约束 eg: alter table student modify id int(11) not null auto_increment; 6) #对已存在的表增加复合主键 eg: alter table service modify add primary key(host_ip,port); 7) # 增加主键 eg: alter table student1 modify name varchar(10) not null primary key; 8) #增加主键和自增长 eg: alter table student modify id int not null primary key auto_increment; 9) #删除主键(先删除自增约束，再删除主键) eg: alter table student modify id int not null; alter table student drop primary key; 复制表 # 复制表结构+内容（key不会被复制，主键、外键和索引） eg: create table new_book select * from book; # 只复制表结构 eg: create table new_book select * from book where 1=2; # 删除表 eg: drop table new_book; :four: 数据操作:deciduous_tree: 单表查询 关键字执行优先级:ballot_box_with_check: # from-->where-->group by-->having-->select-->distinct-->order by-->limit 1) 找到表from #从那张表查 2）拿着where 指定的条件从表中取出一条条记录 3）将取出的一条条记录进行group by分组，没有group by 默认为一组 4）将分组结果having 过滤 5）执行select #选择 6）执行distinct #去重 7）将得到的结果进行排序 order by 8）限制显示结果的条数 WHERE 约束:ballot_box_with_check: 1) 比较运算符：> = != 2) between 80 and 100 值在10到20之间 3) in(80,90,100) 值是10或20或30 4) like 'egon%' pattern可以是%或_，%表示任意多字符_表示一个字符 5) 逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not GROUP BY 分组:ballot_box_with_check: # GROUP BY 关键字 和 GROUP_CONCAT() 函数一起使用 eg: select post GROOUP_CONCAT(name,salary) from employee GROUP BY post; # GROUP BY 关键字 和 聚合函数 一起使用 eg: select post avg(salary) from employee GROUP BY post; HAVING 与 WHERE 不同之处:couplekiss_woman_woman: # 执行优先级 WHERE > GROUP BY > HAVING # WHERE 发生在分组group by 之前，因而where 中可以有任何字段，但是不能有聚合函数 # HAVING 发生在分组 group by之后 因而having可以使用分组字段，不能直接使用其他字段，可以使用聚合函数 ORDER BY 对查询结果排序 # 降序desc 按照年龄排序，年龄相同按照薪资排序 eg：select * from employee order by age, salary desc LIMIT 限制查询结果的记录数 # #从第5开始，即先查询出第6条，然后包含这一条在内往后查5条 eg：select * from employee order by salary desc limit 5,5; REGEXP 使用正则表达式 # 以 ale 开头 eg: select * from employee where name REGEXP '^ale'; # 以 on 结尾 eg: select * from employee where name REGEXP 'on$'; # 查看所有员工中名字是jin开头，n或者g结果的员工信息 eg: select * from employee where name REGEXP '^jin.*[ng]$'; 多表查询 多表链接查询： # 外链接语法 select 字段列表 from 表1 inner|left|right|full join 表2 on 表1.字段=表2.字段 #ps:mysql 不支持full 1) # 交叉链接，不适用任何匹配，笛卡尔积 eg: select * from employee,department 2) # 內链接 inner join，只链接匹配的行 找到两张表的共同部分，相当于利用条件从笛卡尔积中筛选出正确的结果 eg: select employee.id,employee.name,department.name form employeee inner join department on employee.dep_id = department.id; 3) # 左链接 left join，优先显示左表的全部记录 本质是在內链接的基础上增加左边有右边没有的结果 eg: select employee.id,employee.name,department.name from employee left join department on employee.dep_id = department.id; # 无结果适用null填充 4) # 右链接 right join 优先显示右表的全部记录 本质是在內链接的基础上增加左边没有右边有的结果 eg: select employee.id,employee.name,department.name from employee right join department on employee.dep_id = department.id; # 无结果适用null填充 5) # 全外链接，显示左右两个表的全部记录 注意 mysql 不支持full join 但是我们可以构建出这种效果 eg: select * from employee left join department on employee.de_id = department.id union select * from employee right join department on employee.de_id = department.id #注意关键字 union 会去掉相同的记录。 符合条件的链接查询 # 以内连接的方式查询employee和department表，并且以age字段的升序方式显示 eg: select employee.name,employee.age,department.name from employee inner join department where employee.dep_id = department.id and age>25 order by age desc; 子查询 #1：子查询是将一个查询语句嵌套在另一个查询语句中。 #2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。 #3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS(返回True 或者 False) 和 NOT EXISTS等关键字 #4：还可以包含比较运算符：= 、 !=、> 、 25); 2) 带比较运算符的子查询 # 查询大于部门内平均年龄的员工名、年龄 eg: select t1.name,t1.age from employee t1 inner join (select dep_id,vag(age) avg_age from employee group by dep_id) t2 on t1.dep_id = t2.dep_id where t1.age > t2.avg.age; 3) 带EXISTS关键字的子查询 内存查询不返回结果而是返回一个Bolle值，True 或者 False # department表中存在id=200，Ture eg: select * from employee where exists (select id from department where id = 200); 单表链接查询 # 查询每个部门最新入职的那位员工 eg: select * from employee as t1 inner join (select post,max(hire_date) max_date from employee group by post) as t2 on t1.post = t2.post where t1.hire_date = t2.max_date; :five: 索引与慢查询优化:deciduous_tree: 什么是索引？ 索引在mysql中也叫做“键”，是存储引擎快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当数据量越来越大，缩影对性能的影响愈发重要。索引优化是对查询性能优化最有效的手段。 MySQL 常见索引 普通索引 index 唯一索引： 主键索引 primary key :不为空且唯一 唯一索引 unique 唯一 联合索引: PRIMERY KEY(ID,NAME): 联合主键索引 UNIQUE(ID,NAME): 联合唯一索引 INDEX(ID,NAME): 联合普通索引 索引的两大类型hash 和 btree # 我们在创建上述索引的时候，可以为其指定类型，分两类 1) hash 类型索引：查询单条快，范围查询慢 2) btree 类型索引：层数越多，数据量指数级增长(INNODB 默认支持btree) # 不同的存储引擎支持的索引类型 1) INNODB 支持事物，支持行锁，支持btree,full-text 不支持 hash 2) MyISAM 不支持事物，支持表锁，支持btree,full-text 不支持 hash 3) Memory 不支持事物，支持表锁，支持btree，hash 不支持 full-text 4) NDB 支持事物，支持行锁，支持hash 不支持 btree full-text 创建、删除索引 # 建表时创建索引 eg: create table t1(id int,name varchar(20),age int,sex enum(\"male\",\"female\") unique key uni_id(id),# 唯一索引 index ix_name(name)); # 普通索引 # CREATE 在已经建立的表上创建索引 eg: create index ix_age on t1(age) # ALERT TABLE 在已存在的表上建立索引 eg: alter table t1 add index ix_sex(sex); # 删除索引 eg: DROP INDEX 索引名 on 表名； 建立索引的原则 1）最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的,如果建 立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 2）尽量选择区分度高的列作为索引 比如不要用性别来做索引，因为性别无外乎male 和 female 区分度几乎为0 这时候和与全表扫描的磁盘IO没有多大区别，所以速度会很慢。 3）索引列不能参与计算 :six: 数据备份pymysql模块:deciduous_tree: 使用Mysqldump 实现逻辑备份 # 单库备份 mysqldump -uroot -p123 db1> db1.sql mysqldump -uroot -p123 db1 table1 table2 > db1_table1-table2.sql # 单库下面指定表的备份 # 多库备份 mysqldump -uroot -p123 --databases db1 db2 mysql db3 > db1_db2_mysql_db3.sql # 备份所有库 mysql -uroot -p123 --all-datebases > all.sql 恢复逻辑备份 # 进入到备份目录backup下 [root@egon backup]# mysql -uroot -p123 数据库迁移 # 执行数据库迁移务必保证数据库版本相同 mysqldump -h 源ip -uroot -p123 --databases db1 | mysql -h 目标ip -uroot -p456 pymysql模块 1) 链接、执行sql、关闭游标 import pymysql conn=pymysql.connect(host='127.0.0.1',user='root',password='',database='learn',charset='utf8') cursor = conn.cursor #获取游标 sql = 'select * from userinfo where name=\"%s\" and password = \"%s\"%(user,pwd)' # 执行sql res = cursor.execute(sql) # 执行sql,返回sql 查询成功的记录数目 cursor.close()#关闭游标 conn.close() # 关闭链接 2) execute() 之sql注入 # sql 注入的方式 1. --之后的sql均会被注释掉,绕过密码登录 eg: select * from userinfo where name = 'xiang' --'hahahaha' and password = \"123\" 2. 使用or绕过登录,用户名不存在时，1=1 永远成立 eg: select * from userinfo where name = 'xiang' or 1=1 --'hahhaha' and password = '123'; # 解决方式(excute帮我们做字符串拼接) eg: sql='select * from userinfo where name = %s and password = %s' # !!! %s无需加括号 res = cursor.execute(sql,[user,pwd]) :seven: 视图、触发器、事务、存储过程、函数:deciduous_tree: 视图 # 什么是视图 视图是一个虚拟表(非真实存在)，其本质是【根据SQL语句获取动态的数据集，并为其命名】，用户使用时只需要使用【名称】即可获得结果集，可以将该结果集当做表来用，这样再想操作该数据集的时候无需重复写复杂的sql语句了。 # 创建视图 语法CREATE VIEW 视图名称 AS SQL语句 eg: CREATE VIEW teacher_view as select tid from teacher where tname='李平老师'；#注意写关键字VIEW ps: 数据库中只存放视图的定义，不存在视图对应的数据 # 使用视图 1）create view course_view as select * from course;# 创建视图，视图名为course_view 2）update course_view set name = \"xxx\" # 更新视图中的数据 3）insert into course_view values(5,'yyy',2)# 往视图中插入数据 4）select * from course # 发现原始表的记录也跟着修改了 # 修改视图 语法 ALTER VIEW 视图名称 AS SQL语句 eg: alert view teacher_view as select * from teacher where id > 3; # 删除视图 eg: DROP VIEW 视图名 触发器 # 使用触发器可以定制用户对表进行【增、删、改】操作时前后的行为，注意没有查询 1) 创建触发器 eg: delimiter// create trigger tri_after_insert_cmd after insert on cmd for each row begin if new.success = 'no' then insert into errlog(err_cmd,err_time)valuse(new.cmd,new.sub_time); #这里的分号必须加上 end if end// delimiter; # 特别注意：new 表示即将插入的数据行，old 表示即将删除的数据行 2) 使用触发器 # 触发器无法由用户直接调用，而是由对表的【增、删、改】操作被动 触发的 eg: drop brigger tri_after_insert_cmd; 事务 # 事务用于将某些操作的多个sql作为原子操作，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数 据的完成性 eg: start transaction; update user set balance = 100 where name = 'xiang'; # xiang支付了嫖资100块 update user set balance = 10 where name = 'bai'; # 皮条客bai老板 收了10块中介费 update user set balance = 90 where name = 'kun'; # kun小姐 收到了嫖资 90 块 rollback; commit; 存储过程 1）什么是存储过程 存储过程包含了一系列可执行的sql语句，存储过程存放在MySQL中，通过调用它的名字就可以执行它内部的一堆sql语句，使用存储过程可以替代程序写的SQL语句，实现程序和SQL解耦，但是给给程序的扩展带来不便。、 ps: 程序与数据库结合使用的三种方式 1. MySQL：存储过程 程序： 调用存储过程 2. MySQL: 程序： 纯sql语句 3. MySQL: 程序： 类和对象，即ORM(但本质还是sql语句) 2）创建存储过程 eg: delimiter // # 无参 create procedure p1() begin select * from blog; insert into blog(name,sub_time) values ('风清'，now()); end // delimiter; call p1() # 在mysql中调用 cursor.callproc('p1') # 基于pymysql调用 delimiter // # 有参 create procedure p2( in n1 int, in n2 int ) BEGIN SELECT * FROM blog where id > n1; END // delimiter; call p2(3,2) # 在mysql中调用 cursor.callproc('p2',(3,2)) # 基于pymysql调用 3）删除存储过程 drop procedure proc_name 函数 # 常用的MySQL内置函数 聚合函数 AVG(col)返回指定列的平均值 COUNT(col)返回指定列中非NULL值的个数 MIN(col)返回指定列的最小值 MAX(col)返回指定列的最大值 SUM(col)返回指定列的所有值之和 GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果 "},"Python/wtforms 源码流程​​.html":{"url":"Python/wtforms 源码流程​​.html","title":"wtforms 源码流程​​","keywords":"","body":"wtforms 源码流程:four_leaf_clover: Table of contents 源码流程第一步创建类:deciduous_tree: from flask_wtf import FlaskForm # 导入文件的第一步就已经开始执行代码 Class Form(with_metaclass(FormMeta,BaseForm)) # wtforms/form.py 中执行这样一句 def with_metaclass(meta,base=object): # meta 继承了type类，动态创建类的过程 return meta(\"NewBase\",(base,),{}) # 创建了一个NewBase 类，这个类的基类是BaseForm # meta 加括号会执行 FormMeta 的 __init__ 方法 class FormMeta(type): # 执行 __init__ 方法后,NewBase类 以及它的派生类中都增加了两个静态字段 def __init__(cls, name, bases, attrs): type.__init__(cls, name, bases, attrs) cls._unbound_fields = None # 这里的cls 就是 NewBase这个类 cls._wtforms_meta = None 源码流程第二步创建字段:deciduous_tree: from wtforms import StringField,SubmitField from wtforms.validators import DataRequired class MenuForm (FlaskForm): '''菜单表单''' name = StringField (label = \"菜单名称\",validators = [DataRequired (\"菜单不能为空!\")], render_kw = {\"class\":\"form-control\",\"placeholder\":\"请输入菜单名称!\"}) submit = SubmitField (\"提交\",render_kw = {\"class\":\"btn btn-primary\"}) # 创建字段的时候都发生了什么，以StringField 为例 class Field(object): # 实例化StringField会先执行 __init__ 方法，在执行init方法之前会执行new方法 def __new__(cls, *args, **kwargs): if '_form' in kwargs and '_name' in kwargs: return super(Field, cls).__new__(cls) else: return UnboundField(cls, *args, **kwargs) # 这里得到的是一个UnboundField的对象 # 再看看 UnboundField 类实例化的时候都做了什么 class UnboundField(object): _formfield = True creation_counter = 0 def __init__(self, field_class, *args, **kwargs): UnboundField.creation_counter += 1 self.field_class = field_class self.args = args self.kwargs = kwargs self.creation_counter = UnboundField.creation_counter # 这里 得到一个 Creation_counter 计数器，每实例化一次这个技术器都会加一 源码流程第三步，执行FormMeta 类的 __call__ 方法:deciduous_tree: form = MenuForm() # 实例化MenuForm() 类，MenuForm 类继承的NewBase 这个类 而 NewBase 是由 FormMeta 创建的，所以 对象加括号执执行 FormMeta 类的__call__ 方法 def __call__(cls, *args, **kwargs): # _unbound_fields _wtforms_meta 就是刚创建类的时候添加的两个静态字段 if cls._unbound_fields is None: fields = [] for name in dir(cls): # dir 会取得类里所有的属性和方法 if not name.startswith('_'): # 取出 下划线开头的 unbound_field = getattr(cls, name) # 获取自定义字段(就是上面MenuForm中的name字段) if hasattr(unbound_field, '_formfield'): # 如果这个对象里面有_formfield 这个方法或者属性 在UnboundFied 这个类里面定义了一个_formField = True fields.append((name, unbound_field))# 将 字段名和字段对象封装到一个元组中添加到fields 列表中 fields.sort(key=lambda x: (x[1].creation_counter, x[0])) # 按照刚才的计数器进行排序，这里控制的是页面上input 框的显示顺序 cls._unbound_fields = fields # 将排序好的列表赋值给 cls.unbound_fields if cls._wtforms_meta is None: bases = [] for mro_class in cls.__mro__: # __mro__ 获取类之间所有的继承关系 if 'Meta' in mro_class.__dict__:#__dict__ 可以获取类中所有的成员，判断有没有“Meta” bases.append(mro_class.Meta)# 将这些Meta 添加到列表中 cls._wtforms_meta = type('Meta', tuple(bases), {})#动态创建类，继承所有的Meta类 这个时候_wtforms_meta 就是一个继承了所有Meta类的 Meta类了 return type.__call__(cls, *args, **kwargs) 源码流程第四步，执行Form 的 __init__ 方法:deciduous_tree: class Form(with_metaclass(FormMeta, BaseForm)): Meta = DefaultMeta # 这个Meta是DefaultMeta 这个类，在上篇的type动态创建Meta 这个类的时候用到 坑 def __init__(self, formdata=None, obj=None, prefix='', data=None, meta=None, **kwargs): meta_obj = self._wtforms_meta() # Meta 类实例化，执行DefaulMeta的__init__ 方法 if meta is not None and isinstance(meta, dict): # 这里说我们在实例化的时候还可以传一个meta = {\"name\",\"xiang\"} 这样参数 meta_obj.update_values(meta) # 这里会执行DefaultMeta 中的update_value 方法，将meta传过来的字典更新到self的属性中 self 也就是form这个对象 super(Form, self).__init__(self._unbound_fields, meta=meta_obj, prefix=prefix)#这里要执行BaseForm的__init__ 方法 # 执行BaseForm __init__ 方法得到 self._fields[name] = StringField() for name, field in iteritems(self._fields): # 这里紧接着就循环了 self._fields 这个是从BaseForm 里面弄到的 setattr(self, name, field) #这里给self设定了一个属性， self.name = StringField() self.process(formdata, obj, data=data, **kwargs) # 执行Form对象的process方法 源码流程第五步，执行BaseForm的 __init__ 方法:deciduous_tree: class BaseForm(object): def __init__(self, fields, prefix='', meta=DefaultMeta()): if prefix and prefix[-1] not in '-_;:/.': # 处理前缀 prefix += '-' self.meta = meta self._prefix = prefix self._errors = None self._fields = OrderedDict() # 如果这些字段中含有items 方法， 说明fields 中应该会有字典格式的字段对象 if hasattr(fields, 'items'): fields = fields.items() # 这里是处理本地化的，用作翻译错误信息提示 translations = self._get_translations() extra_fields = [] if meta.csrf:# DefaultMeta 中默认 csrf = False 可以设置为True 会给我们自动生成一个[(field_name,unbound_field)] self._csrf = meta.build_csrf(self) # 这里实例化了一个 SessionCSRF()对象 extra_fields.extend(self._csrf.setup_form(self)) #SessionCRSF 对象调用了setup_form()这个方法 这里面给form_meat赋值了，然后还执行了父类的setup_form 方法 return[(field_name,unbound_field)] 这个就是给我自动生成了一个csrf字段 最终是执行了Field 的__call__方法，生成了一个隐藏的input 标签 for name, unbound_field in itertools.chain(fields, extra_fields): # 循环 _unbound_fields，[(field_name,unbound_field)] 注意chain 的用法 options = dict(name=name, prefix=prefix, translations=translations)#这个options字典中封装了字段名，前缀，和translations field = meta.bind_field(self, unbound_field, options) # 这里会执行unbound_field 的bind 方法 return self.field_class(*self.args, **kw) 会得到一个StringField的对象 self._fields[name] = field # 这里创建了一个有序字典 以name 为健，StringField对象为value 如 {\"username\":StringField()} 在上一步中循环 class DefaultMeta(object): # 上面的bind_field返回了一个unboundfield 执行 bind 方法后的结果 def bind_field(self, form, unbound_field, options): \"\"\" :return: A bound field \"\"\" return unbound_field.bind(form=form, **options) # 执行 UnboundField的bind 方法 class UnboundField(object): def bind(self, form, name, prefix='', translations=None, **kwargs): kw = dict( self.kwargs, _form=form, _prefix=prefix, _name=name, _translations=translations, **kwargs ) return self.field_class(*self.args, **kw) # 这个fields_class 就是 StringField 类，返回了这么一个StringField 对象，一直到这里才执行了真正实例化了StringField 类 源码流程第六步，执行BaseForm 的 process 方法:deciduous_tree: def process(self, formdata=None, obj=None, data=None, **kwargs): # 这里是对传进来的formdata 做了一个审核，要求这个formdata必须有getlist 方法，要不然就会报错 formdata = self.meta.wrap_formdata(self, formdata) if data is not None: kwargs = dict(data, **kwargs) for name, field, in iteritems(self._fields):# 这里又循环了self._fields 分别拿到 name 和StringFields()对象 if obj is not None and hasattr(obj, name):# 这里传了obj,并且name(字段)在obj 这个对象中，这一步没有怎么细看，最后得到的结果是self.object_data 和self.data 里面赋值，这是在页面上显示默认值的 到这里Form的__init__ 方法已经执行完了 field.process(formdata, getattr(obj, name)) elif name in kwargs: field.process(formdata, kwargs[name]) else: field.process(formdata) 源码流程第七步，模板渲染:deciduous_tree: # 页面显示标签，需要调用Field 的__str__ 方法 def __str__(self): return self() # 对象加括号执行 Field 的__call__ 方法 def __call__(self, **kwargs): return self.meta.render_field(self, kwargs) # 执行meta 的render_field 方法 ########## meta 类的 render_field 方法 def render_field(self, field, render_kw): other_kw = getattr(field, 'render_kw', None) # 获取 render_kw if other_kw is not None: render_kw = dict(other_kw, **render_kw) # 组成字典 return field.widget(field, **render_kw) # 执行每一个field 的 widget 方法 这里的widget是TexInput 的对象，对象加括号会执行类的__call__ 方法 widget = widgets.TextInput() # 以StringField 为例 # 这里渲染了页面上的标签 def __call__(self, field, **kwargs): kwargs.setdefault('id', field.id) kwargs.setdefault('type', self.input_type) if 'value' not in kwargs: kwargs['value'] = field._value() return HTMLString('' % self.html_params(name=field.name, **kwargs)) 源码流程第八步，执行Form 的 validate 方法 :deciduous_tree: def validate(self): extra = {} # 这个存放我们定义的钩子函数 for name in self._fields: # 循环字段得到name inline = getattr(self.__class__, 'validate_%s' % name, None)# 从MenuForm 中获取validate_name 方法 if inline is not None: extra[name] = [inline] # 写入到字典中 return super(Form, self).validate(extra) # 执行 BaseForm 的validate 方法 ################# def validate(self, extra_validators=None):# extra_validators就是包含钩子函数的字典 self._errors = None success = True for name, field in iteritems(self._fields): # 查看我们定义的钩子函数是否是合法的 if extra_validators is not None and name in extra_validators:# 自定义的钩子函数必须是类中的字段，不能是其它随便的东西 extra = extra_validators[name] # 取得钩子函数 else: extra = tuple() # 如果不是就赋值一个空的元组 if not field.validate(self, extra): # 这里执行的是 field 对象的validate 方法 success = False return success 源码流程第九步，执行Field 的 validate 方法:deciduous_tree: def validate(self, form, extra_validators=tuple()): self.errors = list(self.process_errors) # 默认是一个空元组 stop_validation = False # 预验证，这里可以扩展 try: self.pre_validate(form) except StopValidation as e: if e.args and e.args[0]: self.errors.append(e.args[0]) # 添加错误信息 stop_validation = True except ValueError as e: self.errors.append(e.args[0]) # 执行验证函数 if not stop_validation: # 这里将 validates,和钩子函数 联到一起 chain = itertools.chain(self.validators, extra_validators) stop_validation = self._run_validation_chain(form, chain) # 执行_run_validation_chain # Call post_validate try: self.post_validate(form, stop_validation) # 执行 post_validate 方法 except ValueError as e: self.errors.append(e.args[0]) # 写错误信息 return len(self.errors) == 0 def _run_validation_chain(self, form, validators): for validator in validators: # 循环验证函数 try: validator(form, self) # 执行 验证函数 except StopValidation as e: if e.args and e.args[0]: self.errors.append(e.args[0]) return True except ValueError as e: self.errors.append(e.args[0]) # 添加错误信息 return False def post_validate(self, form, validation_stopped): \"\"\" Override if you need to run any field-level validation tasks after normal validation. This shouldn't be needed in most cases. 这句话是说在执行完上面所有的验证后，你还想写字段级别的验证可以重写这个方法，但是一般情况下你不需这样 \"\"\" pass "},"Python/函数知识体系​​.html":{"url":"Python/函数知识体系​​.html","title":"函数知识体系​​","keywords":"","body":"函数知识体系:four_leaf_clover: Table of contents 函数基础:deciduous_tree: 函数的使用规则：先定义后使用，在定义阶段，只检测语法不执行代码，只有当函数加括号调用的时候，函数内部代码才会执行。 参数的传递顺序：位置参数---->*args(位置参数、元组)---->默认参数----->**kwargs(dict) 如果我们不确定往一个函数中传入多少参数，或者我们希望以元组（tuple）或者列表（list）的形式传参数的时候，我们可以使用args（单星号）。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用*kwargs（双星号），args、kwargs两个标识符是约定俗成的用法。 名称空间与作用域:deciduous_tree: 什么是名称空间：存放变量值与变量名绑定关系的地方就是名称空间。 名称空间加载顺序：内置名称空间---->全局名称空间------>内置名称空间 名称空间LEGB查找规则：locals(内置)---->enclosing(外部函数)------>globals(全局)-------->builtins(内置) 作用域范围：全局范围(内置+全局名称空间) 全局存活、全局有效；局部范围(内置名称空间) 临时存活 局部有效 globals() #查看全局作用域中的名字 locals() # 查看局部作用域中的名字 在局部如果想应用全局作用域中的变量可以用global 关键字 在局部对外部作用域而非全局作用域的引用可以使用nonlocals 关键字 使用nonlocal 关键字需注意 外部不许有这个变量且声明nonlocal 之前不能出现同名变量 x = 5 def myfnc(): print(\"inside myfnc\", x) y = 10 def myfnc2(): global x # 对全局变量的引用 nonlocal y # 对外层(而非全局)函数变量的引用，引用之前不能出现同名变量 print(\"inside myfnc2\", x,y ) x = 10 print(\"x = \", x) y = 1 # 如果不使用nonlocal关键字，直接引用外部变量，自己内部是不能再出现同名变量的(闭包) print(\"y = \", y) myfnc2() myfnc() # inside myfnc 5 # inside myfnc2 5 10 # x = 10 # y = 1 闭包：内部函数包含对外部作用域的引而非全局作用域的引用 判断一个函数是否是闭包函数的方法 __closure__ def func(): x = 1 def inner(): print(x) print(inner.__closure__)#(,) inner是闭包函数 return inner func() 装饰器：开发中的开放封闭原则：对修改封闭，对扩展开放 ；在不修改原函数及其调用方式的情况下对原函数功能进行扩展 def wrapper(func): # 装饰器公式 def inner(*args,**kwargs): # 执行函数前要做的 ret = func(*args,**kwargs) # 执行函数后要做的 return ret return inner ###################################################### from functools import wraps def deco(func): @wraps(func) def wrapper(*args,**kwargs): return func(*args,**kwargs) return wrapper print(index.__doc__) # 获取函数注释 print(index.__name__)# 获取函数名 不使用wraps装饰器的话这里是没有值的 迭代器、生成器:deciduous_tree: 迭代的概念：迭代是一个重复的过程，每一次重复即一次迭代，并且每次迭代的结果都作为下一次迭代的初始值 为什么要有迭代器：提供一种不依赖索引的取值方式(字典、集合、文件是没有索引的) 什么是可迭代对象：可迭代对象指的是内置__ite__ 方法的对象 什么是迭代器对象：可迭代对象执行__iter__ 方法得到的对象就称为迭代器对象；迭代器对象指的是内置有__iter__ 和__next__ 方法的对象，当遍历结束的时候，会触发异常StopIteration。 迭代器一定是可迭代对象，可迭代对象不一定是迭代器(如：字符串) 迭代器为我们提供了一同不依赖索引的取值方式，并且是一种惰性计算，节省内存。但是我们无法获取长度，只有等next执行完毕才知道有多少个值，并且只能往后走不能往前退！ python 中提供两种生成器：包括生成器函数 和生成器表达式 # 生成器函数： 带有yield关键字的函数在python中被称为generator(生成器)，生成器函数使用yield代替return 语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次从离开的地方继续执行 # 生成器表达式：生成器表达式是对列表解析的扩展，生成器是一个特殊的函数，允许返回一个中间值，然后挂起代码 的的执行。列表解析是一次性生成所有的数据，创建的是一个列表对象，不适用于迭代大量的数据 如果读取一个大文件 :heavy_check_mark: def read_line(filename): # 生成器函数实现 BLOCK_SIZE = 1024 with open(filename,\"rb\") as f: while True: block = f.read(BLOCK_SIZE) if block: yield block else: return ##################################################### f = open(\"filename\",\"r\") # 生成器表达式 lines = (x.strip() for x in f) print(lines)## at 0x056EAB10> f.close() send 和 close + 装饰器 实现 协程函数 def init(func): # 装饰器函数 自动触发next 方法 def inner(*args, **kwargs): g = func(*args, **kwargs) next(g) return g return inner @init def piao(name): print(\"%s 准备开始嫖了\" % name) girls = [] while True: girl = yield girls print(\"%s 嫖了 %s\" % (name, girl)) g = piao(\"xiang\") g.send(\"凤姐\") # send 方法同next g.close() # 关闭生成器 g.send('凤姐5') # StopIteration 各种推导式:deciduous_tree: 三元表达式： \"SHADIAO\" if name == \"bai\" else \"DALAO\" 列表推导式： egg_list = [\"鸡蛋%s\"%i for i in range(10)] 生成器表达式： muji = (\"鸡蛋%s\"%i for i in range(10)) # 来个牛逼的列表解析式，找出e大于等于2 的字符串 names = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'], ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']] print([name for lst in names for name in lst if name.count(\"e\")>=2]) 内置函数:deciduous_tree: 截止python 3.6.2,python 一种为我们提供了68个内置函数 数学运算相关7个： abs:求绝对值 eg:abs(-2) #2 divmod:返回连个数的商和余数 eg:divmod(5,2) #(2,1) max:返回可迭代对象元素中的最大值或者所有参数的最大值 eg:max(-1,0,key=abs) # 传入了求绝对值函数 -1 min:返回可迭代对象元素中的最小值或者所有参数的最小值 eg:min(-1,-2,key=abs) # -1 pow:返回数值的幂运算值或者与其指定整数的模值 eg: pow(2,3) # 8 pow(2,3,5) # 3 2和3幂运算得到8之后除以5得3 round:对浮点数进行四舍五入 eg: round(1.34545646456) # 1.3 sum：对元素类型是数值的可迭代对象中的每个元素求值 eg: sum((1,2,3,4)) # 10 类型转换24个： bool: 根据传入的参数的逻辑值创建一个新的布尔值 eg:bool() # False bool(0) False bool(1) True int: 根据传入的参数创建一个新的整数 eg: int(\"12\") # 12 int(3.6) 3 float: 根据传入的参数创建一个新的浮点数 eg: float(3) # 3.0 float(\"3\") 3.0 complex: 根据传入参数创建一个新的复数 eg: complex(1,2) # (1+2j) str: 返回一个对象的字符串表现形式给用户 eg: str(123) # \"123\" bytearray: 根据传入参数创建一个新的字节数组 eg：bytearray(\"中文\"，\"utf-8\") bytes：根据传入的参数创建一个不可变的字节数组 eg:bytearrat(\"中文\",\"utf-8\") b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' memoryview：根据传入的参数创建一个新的内存查看对象 eg:v = memoryview(b'abcefg') v[1] #98 这里的1是索引 ord：返回Unicode字符对应的整数 eg: ord(\"a\") # 97 chr：返回整数所对应的Unicode字符 chr(97) # \"a\" bin：将整数转换成2进制字符串 bin(3) # '0b11' oct：将整数转化成8进制数字符串 oct(10) # '0o12' hex：将整数转换成16进制字符串 hex(15) # '0xf' tuple：根据传入的参数创建一个新的元组 tuple('121') # ('1', '2', '1') list：根据传入的参数创建一个新的列表 dict：根据传入的参数创建一个新的字典 dict(zip(['a','b'],[1,2])) {'b': 2, 'a': 1} set：根据传入的参数创建一个新的集合 frozenset：根据传入的参数创建一个新的不可变集合 enumerate：根据可迭代对象创建枚举对象 range：根据传入的参数创建一个新的range对象 iter：根据传入的参数创建一个新的可迭代对象 a = iter('abcd') slice：根据传入的参数创建一个新的切片对象 slice(1,10,3) # slice(1, 10, 3) 相当于自定义切片 super：根据传入的参数创建一个新的子类和父类关系的代理对象 # 子类 用 父类的方法和属性 object：创建一个新的object对象 序列操作8个： all：判断可迭代对象的每个元素是否都为True值 all([0,1,2]) #列表中0的逻辑值为False，返回False any：判断可迭代对象的元素是否有为True值的元素 any([0,1,2]) #列表元素有一个为True，则返回True filter：使用指定方法过滤可迭代对象的元素 def if_odd(x): #定义奇数判断函数 return x%2==1 list(filter(if_odd,a)) #筛选序列中的奇数 [1, 3, 5, 7, 9] map：使用指定方法去作用传入的每个可迭代对象的元素，生成新的可迭代对象 a = list(map(ord,'abcd')) # [97, 98, 99, 100] ord 返回Unicode字符对应的整数 next：返回可迭代对象中的下一个元素值 reversed：反转序列生成新的可迭代对象 sorted：对可迭代对象进行排序，返回一个新的列表 zip：聚合传入的每个迭代器中相同位置的元素，返回一个新的元组类型迭代器 x = [1,2,3] y = [4,5,6,7,8] list(zip(x,y)) #[(1, 4), (2, 5), (3, 6)] 对象操作7个： help：返回对象的帮助信息 dir：返回对象或者当前作用域内的属性列表 id：返回对象的唯一标识符 hash：获取对象的哈希值 type：返回对象的类型，或者根据传入的参数创建一个新的类型 len：返回对象的长度 ascii：返回对象的可打印表字符串表现方式 ascii('&') # \"'&'\" format：格式化显示值 vars：返回当前作用域内的局部变量和其值组成的字典，或者返回对象的属性列表 反射操作8个： __import__：动态导入模块 isinstance：判断对象是否是类或者类型元组中任意类元素的实例 isinstance(1,(int,str)) True issubclass：判断类是否是另外一个类或者类型元组中任意类元素的子类 issubclass(bool,(str,int)) True hasattr：检查对象是否含有属性 getattr：获取对象的属性值 setattr：设置对象的属性值 delattr：删除对象的属性 callable：检测对象是否可被调用 变量操作2个： globals：返回当前作用域内的全局变量和其值组成的字典 locals：返回当前作用域内的局部变量和其值组成的字典 交互操作2个： print：向标准输出对象打印输出 input：读取用户输入值 文件操作1个： open：使用指定的模式和编码打开文件，返回文件读写对象 编译执行4个： compile：将字符串编译为代码或者AST对象，使之能够通过exec语句来执行或者eval进行求值 eval：执行动态表达式求值 eval('1+2+3+4') # 10 exec：执行动态语句块 a = exec('a=1+2') #执行语句 print(a) 3 repr：返回一个对象的字符串表现形式(给解释器) # a = 'some text' repr(a) \"'some text'\" 装饰器3个： property：标示属性的装饰器 # 装饰过的方法就可以以属性方式调用 classmethod：标示方法为类方法的装饰器 被该装饰器装饰过的方法可被类对象调用(如 C.f())，也可以被类的实例对象调用(如 C().f()) staticmethod：标示方法为静态方法的装饰器 # 调用静态方法不会将实例对象当参数传递，需自行传参 被该装饰器装饰的方法既可以被类调用，也可以被对象调用，但是被类对象调用的时候要求方法至少有一个参数 匿名函数:deciduous_tree: calc = lamdba x: x**x # calc 为函数名 lambda 为关键字 x 为参数 x**x 为返回值 现有两个元组t1 = (('a'),('b')),t2 = (('c'),('d'))，请使用python中匿名函数生成列表[{'a':'c'},{'b':'d'}] list(map(lambda t:{t[0]:t[1]},zip(t1,t2))) 根据字典的值排序 d = {'a':1,'b':4,'c':2} sorted(d.items(),key = lambda x:x[1],reversed = True) # [('b', 4), ('c', 2), ('a', 1)] 递归函数:deciduous_tree: 在一个函数内调用这个函数本身，递归的最大深度997 # 修改递归最大深度 import sys sys.setrecursionlimit(1000) 递归实现二分查找 def bin_search(li,val,low,high): if low val: bin_search(li,val,low,mid-1) if li[mid] "},"Python/常用模块和包​​.html":{"url":"Python/常用模块和包​​.html","title":"常用模块和包​​","keywords":"","body":"常用模块和包:four_leaf_clover: Table of contents collections 模块:deciduous_tree: 除内置数据类型(dict、list、tuple、set) 外，collections 还为我们提供了几个额外的数据类型：Counter、tuple、defaultdict、namedtuple 和 OrderDict 等： namedtuple: 生成一个可以用名字来访问元素的tuple from collections import namedtuple point = namedtuple(\"point\",[\"x\",\"y\"]) p = point(1,3) print(p.x,p.y) # 1,3 deque: 双端队列 from collections import deque q = deque([\"1\",\"2\",\"3\"]) q.appendleft(\"y\") q.append(\"x\") print(q) # [\"y\",\"1\",\"2\",\"3\",\"x\"] 此外还提供 popleft() pop() 等功能 OrdereDict： 有序字典 from collections import OrdereDict od = OrderedDict([('a', 1), ('b', 3), ('c', 2)]) print(od) # OrderedDict([('a', 1), ('b', 3), ('c', 1)]) defaultdict: 带有默认值的字典 Counter: 技术器 from collections impont Counter c = Counter('abcdeabcdabcaba') print(c) # Counter({'a': 5, 'b': 4, 'c': 3, 'd': 2, 'e': 1}) time 模块:deciduous_tree: 表示时间的三种方式 时间戳 time.time() 时间戳是从1970年1月1日00:00:00开始按秒计算的 时间字符串 time.strftime(\"%Y-%m-%d %X\") 当前时间的字符串时间 结构化时间；时间元祖(struct_time) tiem.localtime() localtime将一个时间戳转换为当前时区的struct_time 三种时间格式的相互转换 # 时间戳---->结构化时间 time.gmtime(1500000) 英国伦敦时间 time.localtime() 当地时间 # 结构化时间-->字符串时间 time.strftime(\"%Y-%m-%d %X\") # 字符串时间-->结构化时间 time.strptime(\"2017-03-16\",\"%Y-%m-%d\") # 结构化时间-->时间戳 time.mktime(time.localtime()) random 模块:deciduous_tree: # 随机小数 random.random() # 大于 0 且小于1 之间的小数 random.uniform(1,3) 大于1小于3的小数 # 随机整数 random.randint(1,5) # 大于等于1且小于等于5之间的整数 # 随机选择一个返回 random.choice([1,'23',[4,5]]) # 任意选择一个 # 打乱顺序 item = list(range(10)) random.shuffle(item) OS 模块:deciduous_tree: # 将应用apps、extra_apps 加入根搜索路径 BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) sys.path.insert(0,BASE_DIR) sys.path.insert(0,os.path.join(BASE_DIR,\"apps\")) sys.path.insert(0,os.path.join(BASE_DIR,\"extra_apps\")) # django 配置文件 配置静态资源路径 STATICFILES_DIRS = [os.path.join(BASE_DIR,\"static\")，] # 这个逗号是必须的 json&pickle 模块:deciduous_tree: Json 模块 用于字符串 和 python数据类型间进行转换 提供了四个功能 dumps 和 loads dump 和 load import json # 用于字符串 和 python数据类型间进行转换 dic = {'k1':'v1','k2':'v2','k3':'v3'} str_dic = json.dumps(dic) #序列化：将一个字典转换成一个字符串 print(type(str_dic),str_dic) # {\"k3\": \"v3\", \"k1\": \"v1\", \"k2\": \"v2\"} #注意，json转换完的字符串类型的字典中的字符串是由\"\"表示的 dic2 = json.loads(str_dic) #反序列化：将一个字符串格式的字典转换成一个字典 #注意，要用json的loads功能处理的字符串类型的字典中的字符串必须由\"\"表示 print(type(dic2),dic2) # {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} pickle 用于 python 特有的类型和 python 数据类型间 的转换 import pickle dic = {'k1':'v1','k2':'v2','k3':'v3'} str_dic = pickle.dumps(dic) print(str_dic) #一串二进制内容 dic2 = pickle.loads(str_dic) print(dic2) # {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'} re 模块:deciduous_tree: 正则表达式 # 在代码中用到过的 [0-9a-zA-Z] # 匹配数字，字母 .(点) # 匹配除换行符之外的任意字符 \\d+ # 匹配数字 ^ $ # 开始、结束 () | # 分组 或 / # 贪婪匹配和非贪婪匹配 re 模块的常用方法 re.findall('a', 'xiang bai') ) # 返回满足条件的所有结果，放在列表里 re.search('a', 'xiang bai').group() #查找所有只返回匹配成功的第一条结果，group()调用 扫描整个字符串 re.match('a', 'abc').group() # 同search,不过尽在字符串开始处进行匹配 不存在返回None re 模块 match 和 search 的区别 match() 函数只在字符串开始位置尝试匹配正则，不存在返回None, search() 函数是扫描整个字符串来查找匹配，但只返回匹配成功的第一条结果 hashlib 模块 什么是摘要算法 摘要算法又称哈希算法、散列算法。通过摘要函数f()对任意长度的数据data计算出固定长度的digest,目的是为了发现原始数据是否被篡改过，摘要函数是一个单向函数，对原始数据做一个bit 的修改，都会导致计算出的摘要完全不同，常见的摘要算法有MD5(生成的结果128bit，用一个30位的16进制字符串表示) 和SHA1(生成的结果是160bit,用40位16进制字符串表示) import hashlib md5 = hashlib.md5() ## MD5 md5.update('how to use md5 in python hashlib?'.encode(\"utf-8\")) # python 3 中需对字符串编码 print(md5.hexdigest()) # d26a53750bc40b38b65a520292f69306 sha1 = hashlib.sha1() ## SHA1 sha1.update('how to use sha1 in '.encode(\"utf-8\")) sha1.update('python hashlib?'.encode(\"utf-8\")) print(sha1.hexdigest()) # 2c76b57293ce30acef38d98f6046927161b46a44 logging 模块 "},"Python/爬虫​​.html":{"url":"Python/爬虫​​.html","title":"爬虫​​","keywords":"","body":"爬虫:four_leaf_clover: Table of contents :one: HTTP 协议 Http是超文本传输协议，基于TCP/IP通信协议来传递数据，其特点是无连接、无状态。无连接指的是每次连接只处理一个请求，服务器处理完客户请求，并收到客户应答后，即刻断开连接。HTTP协议是无状态协议。无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传输数据量增大，但在服务器端不需要先前信息时它的响应就会比较快。 HTTP之URL # http使用统一资源定位符url来传输数据和建立连接。一个完整的url应该包括一下几个部分 # http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name 1) 协议部分 http: // 为分隔符 2) 域名部分 www.aspxfans.com 3) 端口部分 域名后面是端口 4) 虚拟目录部分 第一个 / 到最后一个 / 5) 文件名部分 最后一个 / 到 ？为止 6) 参数部分 ？开始到 # 之间 参数与参数之间用 & 符连接 7) 锚部分：从“#”开始到最后，都是锚部分 HTTP 请求消息Request,请求头包含以下格式： 1) 请求行，用来说明请求类型和要访问的资源以及使用HTTP协议的版本。 2) 请求头部，紧接着请求行(即第一行)之后的部分，用来说明服务器要使用的附加信息。 3) 空行，请求头部后面的空行是必须的。 4) 请求数据也叫主体，可以添加任意的其他数据。 HTTP 之响应消息Response，响应头包含以下格式： 1) 状态行，由HTTP协议版本号、状态码、状态消息三部分组成。 # HTTP/1.1 200 OK 2) 消息报头，用来说明客户端要使用的一些附加信息、 3) 空行，消息报头后面的空行是必须的。 4) 响应正文，服务器返回给客户端的文本信息。 常见的状态码 200 OK # 客户端请求成功 400 Bad Request # 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized # 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden # 服务器收到请求，但是拒绝提供服务 404 Not Found # 请求资源不存在，eg：输入了错误的URL 500 Internal Server Error # 服务器发生不可预期的错误 503 Server Unavailable # 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 HTTP 请求生命周期 1）客户端连接到web服务器，一个HTTP客户端，通常是浏览器，与web服务器的HTTP端口建立一个TCP的套接字连接。 2）发送HTTP请求，通过TCP套接字，客户端向web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头 部、空行和请求数据4部分组成。 3）服务器接受请求并返回HTTP响应 web服务器解析请求、定位请求资源、服务器将资源复本写到TCP套接字，由客户 端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4）释放TCP链接，若connection模式为close,则服务器主动关闭TCP连接，若connection模式为keepalive,则连接 会保持一段时间，该时间内可以继续接收请求。 5）客户端浏览器解析HTML内容 GET 和POST 的区别 1）GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连。 2）GET提交的数据有大小限制，而POST方法提交的数据没有限制。 3）GET方式需要使用Request.QueryString来取得变量值，而POST方式通过Request.Form来获取变量值 4）GET提交数据，会带来安全问题。登录密码会被截取 :two: Requests、selenuum 模块 Requests 模块请求参数 headers、params、cookies import requests response=requests.get('https://www.baidu.com/s?wd=python&pn=1', params={ 'wd':'翔', 'pn':1 }, headers={ 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.75 Safari/537.36', }，cookies=Cookies) Requests 模块response属性 respone.text # 获取文本 respone.content # 获取二进制 respone.status_code # 状态码 respone.headers # 响应头 respone.cookies # 获取cookies respone.cookies.get_dict() respone.cookies.items() respone.url # 获取url respone.history respone.encoding #获取编码 ​ "},"Python/网络编程.html":{"url":"Python/网络编程.html","title":"网络编程","keywords":"","body":"网络编程问题合集 Table of contents :one: 简述你对GIL的理解 GIL 的本质其实还是一把互斥锁，都是将并发改成串行，以此来控制同一时刻内共享数据只能被一个任务修改，从而保证数据安全。在python的一个进程内，不仅有用户自己的线程，还有解释器开启的垃圾回收等解释器级别的线程。解释器的代码是所有线程共享的，如果垃圾回收线程和用户自己的线程同时对同一数据进行操作的话，就会存在冲突，所以为了解决这样的问题，就有了全局解释器锁GIL，保证解释器同一时间只能执行一个任务的代码，所以这也就造成了在Cpython中，并不存在真正的多线程，当然也无法利用多核优势。对于计算密集型任务，Cpu越多越好，但是对于I/O密集型任务来说，再多的Cpu也无济于事。对于计算密集型，我们采取多进程来处理。对于I/O密集型，采取多线程，效率反而更高。 :two: 进程、线程的区别以及联系 进程就是一个正在运行的程序或者任务，线程是操作系统中能够进行运算调度的最小单位。它被包含在进程中，是进程的实际运作单位。进程是不能单独运行的，进程只是资源的集合，进程要操作cpu,必须要先创建一个线程，所以在同一个进程中的线程，共享同一进程所占的内存空间。进程中的第一个线程就是主线程，主线程可以创建其他线程，其他线程也可以创建线程，线程之间是平等的。进程有父进程和子进程，拥有独立的内存空间。父进程生成子进程，相当于复制了一份内存空间，进程之间不能直接访问，而是要通过queue来实现进程间内存共享。而线程却可以控制和操作同进程中其它的线程。 :three: 什么是协程，协程是怎么实现的 进程运行过程中有三种状态，分别是运行态、阻塞态、就绪态；遇到IO操作时，进程会被挂起，交出cpu执行权限，处于阻塞态，当IO操作结束后，进入就绪态，等待CPU再次执行，进入运行态；如果我们能在自己的程序中控制单线程下的多个任务能在一个任务遇到IO阻塞就切换到另一个任务去执行，这样就保证了该线程能够最大限度的处于就绪态，即随时能被cup执行的状态，相当于我们在用户程序级别将自己的IO操作最大限度的隐藏起来，从而可以迷惑操作系统，让操作系统认为该线程一直在计算，IO较少，从而将更多的CPU执行权限分配给我们的线程,而这就是协程的本质。协程是一种用户态的轻量级线程，是由用户程序自己控制调度的。要实现上述功能，必须要解决两个问题，一个是切换，一个是保存状态，在python中，Greenlet 模块可以实现多任务之间的切换，但只是单纯的切换，并不能自动检测到IO才进行切换，这样反而降低了效率，所以我们用到了Gevent 模块，在gevent 中用到的主要模式还是Greenlet,Greenlet运行在主程序操作系统内部，但他们被协作式调度；Gevent 模块能够自动检测IO并切换任务，这里需要注意某些IO阻塞，Gevent 是识别不了的 ，我们称这些不能被gevent直接识别的阻塞称为补丁，这时候需要使用引入monkey,执行monkey.patch_all(),这样就可以找到补丁了。注意from gevent import monkey;monkey.patch_all() 放到文件的开头，要不然会识别不到补丁。 "},"Python/面向对象​​.html":{"url":"Python/面向对象​​.html","title":"面向对象​​","keywords":"","body":"面向对象:four_leaf_clover: Table of contents 谈谈你对面向对象的理解：:deciduous_tree: 面向对象是相对于面向过程而言的。面向过程是一种基于功能分析、以算法为中心的程序设计方法；面向对象是一种基于结构分析的、以数据为中心的程序设计思想。以前都说程序=数据结构+算法 ，而在面向对象中，是以对象作为程序运行的基本单元。在面向对象中有一个很重要的东西，叫做类。从面向对象的角度看，类就是一个特殊的数据结构，类里包含了相同的方法和属性。面向对象有三大特征：封装、继承、和 多态。所谓封装，就是指隐藏对象的实现细节，给外界提供公共的方法来访问；对于用户来说，我们可以不必要关心每一个对象实现的细节，只要关注类为我们提供的接口实现功能就行。 面向对象的第二个特征：继承，子类可以继承基类的公共属性和方法,但是无法继承基类的私有属性和方法。子类不但可以继承基类属性和方法，也可以添加自己的属性和方法，还可以对基类的方法重写；不同的子类可能会将基类的方法重写成不同的方法，这样不同的实例对象实现相同的接口，执行不同的操作呈现出来不同的结果的现象称为多态。 接口类实现的两种方式:deciduous_tree: 主动抛异常 class Payment: def pay(self,money): raise NotImplementedError class Wechatpay(Payment): def fuqian(self,money): print('微信支付了%s元'%money) p = Wechatpay() #这里不报错 p.pay(100) # 这里抛异常NotImplementedError 使用abc模块来实现接口 from abc import ABCMeta,abstractmethod class Payment(metaclass = ABCMeta): @abstractmethod def pay(self,money): pass class Wechatpay(Payment): def fuqian(self,money): print('微信支付了%s元'%money) p = Wechatpay() # 不调用就不会报错 新式类和经典类:deciduous_tree: 在python2中默认是经典类，在python3中默认都是新式类 当类是经典类的时候，多继承的情况下，会按照深度优先的方式进行查找 当类是新式类的时候，多继承的情况下，会按照广度优先的方式进行查找 面向对象的属性:deciduous_tree: property 属性 方法 属性方法就是通过使用装饰器 @property , 将一个方法变成一个静态属性 , 于是我们就可以通过访问属性 , 来或得一个方法的返回值 classmethod 类方法 类方法通过@classmethod装饰器，将普通方法变成类方法，类方法只能与类属性交互，不能访问实例变量，并且默认有一个cls 参数表示本类 staticmethod 静态方法 静态方法是通过@staticmethod装饰器，将类中的一个方法变为一个静态方法 静态方法就像静态属性一样，在类中可以通过self来调用，但是静态方法不能访问实例变量和类变量的。 isinstance 和 issubclass:deciduous_tree: isinstance(obj,cls) 检查obj 是否为cls 的实例对象 issuclass(sub,super) 检查sbu 类是否是super 的派生类 "}}