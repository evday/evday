# 网络编程问题合集

## Table of contents

<extoc></extoc>

## :one: 简述你对GIL的理解

GIL 的本质其实还是一把互斥锁，都是将并发改成串行，以此来控制同一时刻内共享数据只能被一个任务修改，从而保证数据安全。在python的一个进程内，不仅有用户自己的线程，还有解释器开启的垃圾回收等解释器级别的线程。解释器的代码是所有线程共享的，如果垃圾回收线程和用户自己的线程同时对同一数据进行操作的话，就会存在冲突，所以为了解决这样的问题，就有了全局解释器锁GIL，保证解释器同一时间只能执行一个任务的代码，所以这也就造成了在Cpython中，并不存在真正的多线程，当然也无法利用多核优势。对于计算密集型任务，Cpu越多越好，但是对于I/O密集型任务来说，再多的Cpu也无济于事。对于计算密集型，我们采取多进程来处理。对于I/O密集型，采取多线程，效率反而更高。

## :two: 进程、线程的区别以及联系

进程就是一个正在运行的程序或者任务，线程是操作系统中能够进行运算调度的最小单位。它被包含在进程中，是进程的实际运作单位。进程是不能单独运行的，进程只是资源的集合，进程要操作cpu,必须要先创建一个线程，所以在同一个进程中的线程，共享同一进程所占的内存空间。进程中的第一个线程就是主线程，主线程可以创建其他线程，其他线程也可以创建线程，线程之间是平等的。进程有父进程和子进程，拥有独立的内存空间。父进程生成子进程，相当于复制了一份内存空间，进程之间不能直接访问，而是要通过queue来实现进程间内存共享。而线程却可以控制和操作同进程中其它的线程。

## :three: 什么是协程，协程是怎么实现的

进程运行过程中有三种状态，分别是运行态、阻塞态、就绪态；遇到IO操作时，进程会被挂起，交出cpu执行权限，处于阻塞态，当IO操作结束后，进入就绪态，等待CPU再次执行，进入运行态；如果我们能在自己的程序中控制单线程下的多个任务能在一个任务遇到IO阻塞就切换到另一个任务去执行，这样就保证了该线程能够最大限度的处于就绪态，即随时能被cup执行的状态，相当于我们在用户程序级别将自己的IO操作最大限度的隐藏起来，从而可以迷惑操作系统，让操作系统认为该线程一直在计算，IO较少，从而将更多的CPU执行权限分配给我们的线程,而这就是协程的本质。协程是一种用户态的轻量级线程，是由用户程序自己控制调度的。要实现上述功能，必须要解决两个问题，一个是切换，一个是保存状态，在python中，Greenlet 模块可以实现多任务之间的切换，但只是单纯的切换，并不能自动检测到IO才进行切换，这样反而降低了效率，所以我们用到了Gevent 模块，在gevent 中用到的主要模式还是Greenlet,Greenlet运行在主程序操作系统内部，但他们被协作式调度；Gevent 模块能够自动检测IO并切换任务，这里需要注意某些IO阻塞，Gevent 是识别不了的 ，我们称这些不能被gevent直接识别的阻塞称为补丁，这时候需要使用引入monkey,执行monkey.patch_all(),这样就可以找到补丁了。注意from gevent import monkey;monkey.patch_all() 放到文件的开头，要不然会识别不到补丁。











